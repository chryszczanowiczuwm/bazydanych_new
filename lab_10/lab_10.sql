# zadanie 1

CREATE TABLE IF NOT EXISTS ORDER_STATUS_HISTORY (
    HISTORY_ID INT AUTO_INCREMENT PRIMARY KEY,
    ORDER_NUMBER VARCHAR(50),
    CHANGE_DATE DATETIME,
    NEW_STATUS_NAME VARCHAR(255)
);

DELIMITER $$

DROP TRIGGER IF EXISTS order_status_change_log $$
CREATE TRIGGER order_status_change_log
AFTER UPDATE ON `ORDER`
FOR EACH ROW
BEGIN
    DECLARE v_status_name VARCHAR(255);

    IF NEW.ORDER_STATUS <> OLD.ORDER_STATUS THEN
        SELECT s.nazwa_statusu
        INTO v_status_name
        FROM status s
        WHERE s.id_statusu = NEW.ORDER_STATUS
        LIMIT 1;

        INSERT INTO ORDER_STATUS_HISTORY (ORDER_NUMBER, CHANGE_DATE, NEW_STATUS_NAME)
        VALUES (NEW.ORDER_NUMBER, NOW(), v_status_name);
    END IF;
END $$

DELIMITER ;



# zadanie 2


DELIMITER $$

DROP TRIGGER IF EXISTS order_position_check_inventory $$
CREATE TRIGGER order_position_check_inventory
BEFORE INSERT ON ORDER_POSITION
FOR EACH ROW
BEGIN
    DECLARE v_stock DECIMAL(7,2);

    SELECT i.AMOUNT
      INTO v_stock
      FROM INVENTORY i
     WHERE i.PRODUCT_ID = NEW.PRODUCT_ID
     LIMIT 1;

    IF v_stock IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Produkt nie istnieje w INVENTORY';
    END IF;

    IF v_stock < NEW.AMOUNT THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Brak wystarczającej ilości produktu w INVENTORY';
    END IF;
END $$

DELIMITER ;


# zadanie 3

DELIMITER $$

DROP PROCEDURE IF EXISTS product_find_by_phrase $$
CREATE PROCEDURE product_find_by_phrase(IN p_phrase VARCHAR(255))
BEGIN
    SELECT *
    FROM PRODUCT
    WHERE PRODUCT_NAME LIKE CONCAT('%', p_phrase, '%')
       OR COALESCE(DESCRIPTION,'') LIKE CONCAT('%', p_phrase, '%');
END $$

DELIMITER ;


# zadanie 4

DELIMITER $$

DROP FUNCTION IF EXISTS income_for_month $$
CREATE FUNCTION income_for_month(p_year INT, p_month INT)
RETURNS DECIMAL(12,2)
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE v_income DECIMAL(12,2);

    SELECT COALESCE(SUM(op.AMOUNT * op.SELL_PRICE), 0.00)
    INTO v_income
    FROM `ORDER` o
    JOIN ORDER_POSITION op ON op.ORDER_ID = o.ORDER_ID
    WHERE YEAR(o.ORDER_DATE) = p_year
      AND MONTH(o.ORDER_DATE) = p_month
      AND o.ORDER_STATUS = 3;

    RETURN v_income;
END $$

DELIMITER ;


# zadanie 5

DROP TRIGGER IF EXISTS order_before_delete_archive;
DROP PROCEDURE IF EXISTS archive_order_before_delete;

DROP TABLE IF EXISTS ORDER_POSITION_ARCHIVE;
DROP TABLE IF EXISTS ORDER_ARCHIVE;

CREATE TABLE ORDER_ARCHIVE LIKE `ORDER`;
CREATE TABLE ORDER_POSITION_ARCHIVE LIKE ORDER_POSITION;

ALTER TABLE ORDER_ARCHIVE
    ADD COLUMN ORIGINAL_ORDER_ID INT UNSIGNED,
    ADD COLUMN ARCHIVED_AT DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;

ALTER TABLE ORDER_POSITION_ARCHIVE
    ADD COLUMN ORIGINAL_ORDER_ID INT UNSIGNED,
    ADD COLUMN ARCHIVED_AT DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;

ALTER TABLE ORDER_ARCHIVE
    MODIFY ORDER_ID INT UNSIGNED NOT NULL AUTO_INCREMENT,
    ADD PRIMARY KEY (ORDER_ID);

DELIMITER $$

CREATE PROCEDURE archive_order_before_delete(IN p_order_id INT UNSIGNED, OUT p_new_archive_order_id INT UNSIGNED)
BEGIN
    INSERT INTO ORDER_ARCHIVE (CLIENT_ID, EMPLOYEE_ID, ORDER_DATE, ORDER_NUMBER, ORDER_STATUS, ORIGINAL_ORDER_ID, ARCHIVED_AT)
    SELECT o.CLIENT_ID, o.EMPLOYEE_ID, o.ORDER_DATE, o.ORDER_NUMBER, o.ORDER_STATUS, o.ORDER_ID, NOW()
    FROM `ORDER` o
    WHERE o.ORDER_ID = p_order_id;

    SET p_new_archive_order_id = LAST_INSERT_ID();

    INSERT INTO ORDER_POSITION_ARCHIVE (ORDER_ID, PRODUCT_ID, AMOUNT, SELL_PRICE, ORIGINAL_ORDER_ID, ARCHIVED_AT)
    SELECT p_new_archive_order_id, op.PRODUCT_ID, op.AMOUNT, op.SELL_PRICE, op.ORDER_ID, NOW()
    FROM ORDER_POSITION op
    WHERE op.ORDER_ID = p_order_id;
END $$

CREATE TRIGGER order_before_delete_archive
BEFORE DELETE ON `ORDER`
FOR EACH ROW
BEGIN
    DECLARE v_new_id INT UNSIGNED;
    CALL archive_order_before_delete(OLD.ORDER_ID, v_new_id);
END $$

DELIMITER ;
